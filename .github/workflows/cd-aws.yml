name: CD-AWS

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  GO_VERSION: "1.22"
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}

jobs:
  build-and-push:
    name: Build and Push to ECR
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=sha-${GITHUB_SHA::8}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          services=(
            "aex-gateway"
            "aex-work-publisher"
            "aex-bid-gateway"
            "aex-bid-evaluator"
            "aex-contract-engine"
            "aex-provider-registry"
            "aex-trust-broker"
            "aex-identity"
            "aex-settlement"
            "aex-telemetry"
          )
          
          for service in "${services[@]}"; do
            echo "Building and pushing $service..."
            
            docker build \
              -f "src/$service/Dockerfile" \
              -t "$ECR_REGISTRY/agent-exchange/$service:$VERSION" \
              -t "$ECR_REGISTRY/agent-exchange/$service:latest" \
              src/
            
            docker push "$ECR_REGISTRY/agent-exchange/$service:$VERSION"
            docker push "$ECR_REGISTRY/agent-exchange/$service:latest"
          done

  deploy-staging:
    name: Deploy to Staging (AWS)
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event.inputs.environment == 'staging' || (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/'))
    environment: aws-staging
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to ECS (Staging)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          VERSION: ${{ needs.build-and-push.outputs.version }}
          CLUSTER_NAME: aex-cluster-staging
        run: |
          services=(
            "aex-gateway"
            "aex-work-publisher"
            "aex-bid-gateway"
            "aex-bid-evaluator"
            "aex-contract-engine"
            "aex-provider-registry"
            "aex-trust-broker"
            "aex-identity"
            "aex-settlement"
            "aex-telemetry"
          )
          
          for service in "${services[@]}"; do
            echo "Deploying $service to staging..."
            
            SERVICE_NAME="$service-staging"
            IMAGE="$ECR_REGISTRY/agent-exchange/$service:$VERSION"
            
            # Get current task definition
            TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition "$SERVICE_NAME" \
              --query 'taskDefinition' \
              --output json 2>/dev/null || echo '{}')
            
            if [ "$TASK_DEF" = "{}" ]; then
              echo "  Task definition not found, skipping (run setup first)"
              continue
            fi
            
            # Update image in task definition
            NEW_TASK_DEF=$(echo "$TASK_DEF" | jq \
              --arg IMAGE "$IMAGE" \
              '.containerDefinitions[0].image = $IMAGE | 
               del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
            
            # Register new task definition
            NEW_TASK_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEF" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            # Update service
            aws ecs update-service \
              --cluster "$CLUSTER_NAME" \
              --service "$SERVICE_NAME" \
              --task-definition "$NEW_TASK_ARN" \
              --force-new-deployment \
              --output text > /dev/null
            
            echo "  Deployed $service to staging"
          done

      - name: Wait for staging deployment
        env:
          CLUSTER_NAME: aex-cluster-staging
        run: |
          echo "Waiting for services to stabilize..."
          
          services=(
            "aex-gateway-staging"
            "aex-work-publisher-staging"
          )
          
          for service in "${services[@]}"; do
            echo "  Waiting for $service..."
            aws ecs wait services-stable \
              --cluster "$CLUSTER_NAME" \
              --services "$service" \
              --region "$AWS_REGION" || true
          done
          
          echo "Staging deployment complete!"

  deploy-production:
    name: Deploy to Production (AWS)
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    if: github.event.inputs.environment == 'production' || (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))
    environment: aws-production
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to ECS (Production)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          VERSION: ${{ needs.build-and-push.outputs.version }}
          CLUSTER_NAME: aex-cluster
        run: |
          services=(
            "aex-gateway"
            "aex-work-publisher"
            "aex-bid-gateway"
            "aex-bid-evaluator"
            "aex-contract-engine"
            "aex-provider-registry"
            "aex-trust-broker"
            "aex-identity"
            "aex-settlement"
            "aex-telemetry"
          )
          
          for service in "${services[@]}"; do
            echo "Deploying $service to production..."
            
            SERVICE_NAME="$service"
            IMAGE="$ECR_REGISTRY/agent-exchange/$service:$VERSION"
            
            # Get current task definition
            TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition "$SERVICE_NAME" \
              --query 'taskDefinition' \
              --output json 2>/dev/null || echo '{}')
            
            if [ "$TASK_DEF" = "{}" ]; then
              echo "  Task definition not found, skipping (run setup first)"
              continue
            fi
            
            # Update image in task definition
            NEW_TASK_DEF=$(echo "$TASK_DEF" | jq \
              --arg IMAGE "$IMAGE" \
              '.containerDefinitions[0].image = $IMAGE | 
               del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
            
            # Register new task definition
            NEW_TASK_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEF" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            # Update service with rolling deployment
            aws ecs update-service \
              --cluster "$CLUSTER_NAME" \
              --service "$SERVICE_NAME" \
              --task-definition "$NEW_TASK_ARN" \
              --deployment-configuration "minimumHealthyPercent=100,maximumPercent=200" \
              --force-new-deployment \
              --output text > /dev/null
            
            echo "  Deployed $service to production"
          done

      - name: Wait for production deployment
        env:
          CLUSTER_NAME: aex-cluster
        run: |
          echo "Waiting for services to stabilize..."
          
          # Wait for critical services first
          aws ecs wait services-stable \
            --cluster "$CLUSTER_NAME" \
            --services "aex-gateway" "aex-work-publisher" \
            --region "$AWS_REGION" || true
          
          echo "Production deployment complete!"

      - name: Create release notes
        if: startsWith(github.ref, 'refs/tags/v')
        uses: actions/github-script@v7
        with:
          script: |
            const tag = context.ref.replace('refs/tags/', '');
            
            // Check if release already exists
            try {
              const { data: existingRelease } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tag
              });
              
              // Update existing release
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: existingRelease.id,
                body: existingRelease.body + `\n\n**AWS Deployment:** Deployed to production.`
              });
              console.log(`Updated release: ${existingRelease.html_url}`);
            } catch (e) {
              // Create new release
              const { data: release } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                name: `Release ${tag}`,
                body: `Automated release for ${tag}\n\nDeployed to AWS production.`,
                draft: false,
                prerelease: false
              });
              console.log(`Created release: ${release.html_url}`);
            }

  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging, deploy-production]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "## AWS Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Push | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Staging | ${{ needs.deploy-staging.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Production | ${{ needs.deploy-production.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.build-and-push.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY


